<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"
      autoReload="true"
      throwExceptions="false"
      internalLogLevel="Warn"
      internalLogFile="c:\temp\nlog-internal.log">
  <variable name="myvar" value="myvalue"/>
  <targets>
    <!-- write logs to file -->
    <target name="file" xsi:type="AsyncWrapper" queueLimit="5000" overflowAction="Discard">
      <target xsi:type="File" fileName="${basedir}/logs/${shortdate}.log"
              layout="${longdate} ${level:uppercase=true} ${event-context:item=Action} ${message} ${event-context:item=Amount} ${stacktrace}" />
    </target>
    <!--write log message to Visual Studio Output-->
    <target name="debugger" xsi:type="Debugger"
            layout="NLog: ${date:format=HH\:mm\:ss} | ${level:uppercase=true:padding=-5} | ${message}" />
    <!-- write log message to database -->
    <target name="Database" xsi:type="Database" keepConnection="false"
          dbProvider="System.Data.SQLite.SQLiteConnection, System.Data.SQLite, Version=1.0.111.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139"
          connectionString="Data Source=logs/log.db3;Version=3;"
          commandType="Text"
          commandText="INSERT into NLogX(Time, Level, Threadname, Source, SourceDetails, Message, MessageID, Logger, CallSite, Exception) 
            values(@Time, @Level, @Threadname, @Source, @SourceDetails, @Message, @MessageID, @Logger, @CallSite, @Exception)">
      <parameter name="@time" layout="${date}" />
      <parameter name="@level" layout="${level}" />
      <parameter name="@threadname" layout="${threadname}" />
      <parameter name="@source" layout="${event-context:item=Source}" />
      <parameter name="@sourceDetails" layout="${event-context:item=SourceDetails}" />
      <parameter name="@message" layout="${message}" />
      <parameter name="@messageID" layout="${event-context:item=MessageID}" />
      <parameter name="@logger" layout="${logger}" />
      <parameter name="@callSite" layout="${callsite:filename=true}" />
      <parameter name="@exception" layout="${exception:tostring}" />
    </target>
  </targets>

  <rules>
    <!-- add your logging rules here -->
    <!--TRACE,DEBUG,INFO,WARN,ERROR,FATAL-->
    <logger name="*" minlevel="Trace" writeTo="debugger" />
    <!--INFO,WARN,ERROR,FATAL-->
    <logger name="*" minlevel="Info" writeTo="Database" />
    <!--DEBUG,INFO,WARN,ERROR,FATAL-->
    <logger name="*" minlevel="Debug" writeTo="file" />
    <!--
    Write all events with minimal level of Debug (So Debug, Info, Warn, Error and Fatal, but not Trace)  to "f"
    <logger name="*" minlevel="Debug" writeTo="f" />
    -->
  </rules>
</nlog>
<!--
https://www.cnblogs.com/felixnet/p/5498759.html
如在根节点（nlog）配置 internalLogLevel, internalLogFile，可以查看NLog输出日志时的内部信息，比如你配置文件有错误，很有帮助，不过项目发布后还是关闭比较好，以免影响效率；
在target外面罩了一个 <target>并且xsi:type为 AsyncWrapper，即表示这条 target 将异步输出，这里我将文件和数据库日志异步输出；
db target内指定了数据库连接字符串 connectionString，SQL语句，SQL参数，还可以指定数据库/表创建和删除的脚本（推荐看NLog源码示例，这里不介绍），同时我们自定义了2个参数 action和amount；
target参数里有些是NLog内置参数，比如message,level,date,longdate,exception,stacktrace等，NLog在输出时会自动赋值；
layout设置了每条日志的格式；
在rules节点，我们分别指定了三个target输出日志的级别，NLog用于输出日志的级别包括：Trace,Debug,Info,Warn,Error,Fatal，可以设置 minlevel设置最小级别，也可以用 levels定义你所有需要的级别（多个用逗号分隔）。
-->
<!--
NLog.Logger logger = Nlog.LogManager.GetCurrentClassLogger();
logger.Fatal("发生致命错误");
logger.Warn("警告信息");
-->
<!--
Logger.Default.Trace("Hello World! Trace");
Logger.Default.Info("Hello World! Info");
Logger.Default.Warn("Hello World! Warn");
Logger.Default.Debug("Hello World! Debug");
Logger.Default.Error("Hello World! Error");
Logger.Default.Fatal("Hello World! Fatal");

Logger.Default.Process(new Models.Log(Models.EFLogLevel.Info, "Hello World! Info", "TEST", "100.00"));
Logger.Default.Process(new Models.Log(Models.EFLogLevel.Debug, "Hello World! Debug", "TEST", "100.00"));
Logger.Default.Process(new Models.Log(Models.EFLogLevel.Error, "Hello World! Error", "TEST", "100.00"));
Logger.Default.Flush();
-->
<!--
https://www.cnblogs.com/liningit/p/4844292.html
CREATE TABLE NLogX (
    Id          INTEGER        PRIMARY KEY AUTOINCREMENT,
    Time        DATETIME,
    Level       NVARCHAR (16),
    Threadname    NVARCHAR (32),
    Source      NVARCHAR (32),
    SourceDetails      NVARCHAR (32),
    Message     NVARCHAR (50),
    MessageId   INTEGER,
    Logger      NVARCHAR (250),
    Callsite    NVARCHAR (512),
    Exception   NVARCHAR (512)
    )
  -->
<!--
待深入
public class DBLog
    {
        readonly static Logger processLogger = LogManager.GetLogger("LnProcessDBLog");

        public static void Process(string key,string userName, string orderNo, string content, string keyWord)
        {
            LogEventInfo theEvent = new LogEventInfo(LogLevel.Info, "", content);
            theEvent.Properties["RequestKey"] = key;
            theEvent.Properties["UserName"] = userName;
            theEvent.Properties["OrderNo"] = orderNo;
            theEvent.Properties["KeyWord"] = keyWord;
            processLogger.Log(theEvent);
        }

        public static void Flush()
        {
            LogManager.Flush();
        }
    }
  -->
<!--
${activityid}	将其置入日志System.Diagnostics trace 
${all-event-properties}	事件日志上下文
${appdomain}	当前应用程序域
${assembly-version}	应用程序
${basedir}	应用程序域的基本目录。
${callsite}	(类名称、方法名称和相关信息的源信息)。
${callsite-linenumber}	调用类的
${counter}	数值
${date}	当前日期和时间。
${document-uri}	用于Silverlight应用。
${environment}	环境变量
${event-properties}	 
${exception}	exception信息
${file-contents}	显示指定文件的内容
${gc}	垃圾收集器
${gdc}	诊断上下文
${guid}	GUID
${identity}	线程标识信息
${install-context}	安装参数
${level}	级别。
${literal}	 
${log4jxmlevent}	XML事件描述
${logger}	记录器的名字
${longdate}	日期和时间的格式分类yyyy-MM-dd HH:mm:ss.ffff。
${machinename}	名称
${mdc} 	映射诊断
${mdlc}	异步映射诊断上下文
${message}	消息
${ndc}	线程结构
${ndlc}	异步线程
${newline}	文字换行
${nlogdir}	nlog.dll目录。
${performancecounter}	述性能计数器。
${processid}	当前进程标识符
${processinfo}	运行信息
${processname}	当前进程的名称。
${processtime}	该时间过程中格式HH:MM:ss.mmm。
${qpc}	高精度定时器，基于返回的值从queryperformancecounter(任选地)转换为秒。
${registry}	从注册表中的值。
${sequenceid}	ID
${shortdate}	短时间 格式YYYY-MM-DD。
${sl-appinfo}	Silverlight应用。
${specialfolder}	文件夹路径
${stacktrace} -	堆栈跟踪渲染器。
${tempdir}	临时目录中。
${threadid}	当前线程的标识符。
${threadname}	当前线程。
${ticks}	当前日期和时间。
${time}	24小时格式HH:MM:ss.mmm。
${var}	{$var}-提供新的变量(4.1)
${windows-identity}	indows线程标识信息(用户名)
-->